<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Bayesian Leakage Analysis (part 1) | Seny Kamara </title> <meta name="author" content="Seny Kamara"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://senykam.github.io/blog/2026/bayesian-1/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Seny</span> Kamara </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">home </a> </li> <li class="nav-item "> <a class="nav-link" href="/writing/index.html">writing </a> </li> <li class="nav-item "> <a class="nav-link" href="/papers/">papers </a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">talks </a> </li> <li class="nav-item "> <a class="nav-link" href="/activities/">activities </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching+students/">teaching+students </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Bayesian Leakage Analysis (part 1)</h1> <p class="post-meta"> February 11, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="bayesian-leakage-analysis-part-1-what-does-it-mean-to-exploit-leakage">Bayesian Leakage Analysis, Part 1: What Does It Mean to Exploit Leakage?</h1> <p>Leakage profiles are now standard in encrypted-search security definitions, and rightly so. They make explicit what an adversary can observe, they enable meaningful comparisons between schemes, and they give designers concrete targets. But once a profile is written down, a natural question follows: <em>how exploitable is it?</em></p> <p>That question turns out to be harder than it looks. A leakage profile describes what is observable. Exploitability depends on what an adversary can <em>do</em> with those observations, which in turn depends on the adversary’s auxiliary information, the structure of the hidden variables, and the objective the adversary is trying to achieve. Two profiles that look equally revealing can have very different exploitability characteristics under realistic conditions. Two profiles that look harmless can become damaging when paired with the right auxiliary distribution.</p> <p>This post describes a framework that makes these dependencies precise. The core idea is that leakage exploitation is a Bayesian inference problem, and that treating it as one gives us both a useful metric for exploitability and structural bounds that separate the different sources of inferential difficulty. A companion <a href="./02-from-section8-bayesian-networks-and-automated-attacks.md">second post</a> covers the automation layer that turns this framework into a reusable attack engine.</p> <h2 id="the-problem-with-recovery-rate">The Problem with Recovery Rate</h2> <p>Consider a concrete scenario. An adversary attacks an encrypted database using query-equality leakage and achieves 85% recovery of the underlying queries. Is that a lot? The answer depends entirely on what would have happened without the leakage.</p> <p>Suppose the adversary has strong auxiliary information about the query distribution — say, a Zipf model with good parameter estimates. In many realistic regimes, the mode of that distribution is already quite peaked. A baseline adversary that ignores leakage entirely and simply guesses from the auxiliary distribution might already achieve 75% recovery. In that case, the leakage contributed only 10 percentage points of additional success, not 85.</p> <p>This is not an edge case. In encrypted search, auxiliary information often comes from public corpora, known-data fractions, or structural priors, and these can be strong. Raw recovery rate confounds two effects: the strength of the prior and the incremental value of leakage. If we want to understand what leakage itself contributes — which is the question a scheme designer actually needs to answer — we need to subtract the baseline.</p> <p><img src="../figures/advantage_gap.png" alt="Same recovery rate, different conclusions about leakage"></p> <p>We define <em>advantage</em> as the absolute gap in success probability between an adversary that uses both leakage and auxiliary information, and one that uses auxiliary information alone. This is a simple change, but its consequences are significant. It means that a high-advantage leakage profile is one that genuinely helps an adversary beyond what they could do with prior knowledge, and a low-advantage profile is one where leakage adds little even if raw recovery numbers look impressive.</p> <h2 id="the-inference-model">The Inference Model</h2> <p>To make advantage precise, we need to say what the adversary’s inference problem actually looks like. We model a leakage setting as a joint random variable [ \mathbf{X}=(\mathbf{S},\mathbf{H},\mathbf{L}), ] where (\mathbf{S}) is the secret (the thing the adversary wants to recover), (\mathbf{H}) captures hidden structure (such as a random permutation that maps queries to leakage symbols), and (\mathbf{L}) is the observed leakage. The adversary brings an auxiliary distribution (\alpha) over the secret space, which represents its prior beliefs.</p> <p><img src="../figures/inference_pipeline.png" alt="The inference pipeline: from leakage model to secret recovery"></p> <p>The reason for writing things this way is not formalism for its own sake. It forces every leakage analysis to be explicit about what is secret, what is hidden, what is observed, and what the adversary assumes. In practice, many attack papers mix these assumptions implicitly — they sample data one way, generate auxiliary information another way, and define success in a way that makes it hard to tell what caused recovery. When ((\mathbf{S}, \mathbf{H}, \mathbf{L}, \alpha)) are written down together, assumptions become testable.</p> <p>Given observed leakage (\ell), the adversary computes a posterior over secrets by combining the likelihood (which comes from the leakage model) with the prior (which comes from auxiliary information). The attack is then whatever decision rule the adversary applies to that posterior. For full recovery, the natural choice is MAP estimation — guessing the secret with the highest posterior probability. For functional recovery (recovering some function of the secret rather than the secret itself), we define analogous MAP-test estimators. These are not the only possible adversaries, but they are strong, standard, and structured enough to support precise analysis.</p> <h2 id="three-sources-of-difficulty">Three Sources of Difficulty</h2> <p>The central technical result for these adversaries is a bound that decomposes MAP advantage into three terms: [ \operatorname{Adv} \le 2^{-\Lambda_\infty} + 2^{-\Sigma} + 2^{-\chi}. ] Each term captures a distinct mechanism that makes leakage exploitation harder.</p> <p><strong>Leakage entropy</strong> ((\Lambda_\infty)) measures how ambiguous the leakage is about the secret, once auxiliary information is accounted for. When the leakage strongly concentrates the posterior on one candidate, leakage entropy is high and this term is small. When many candidates remain plausible under the posterior, this term dominates.</p> <p><strong>Singular entropy</strong> ((\Sigma)) measures the extent to which the leakage model permits direct inversion — whether the mapping from secrets to leakage is one-to-one or many-to-one. When the leakage function is injective (every secret produces a different observation), this term vanishes. When many secrets map to the same leakage symbol, singular entropy contributes real difficulty.</p> <p><strong>Modal entropy</strong> ((\chi)) captures the alignment between the true secret distribution and the adversary’s auxiliary distribution. Even if the adversary has a good model of the distribution shape, if the ranking of the most likely values is wrong, the MAP estimator’s mode-seeking behavior can lead it astray.</p> <p><img src="../figures/three_barriers.png" alt="Three independent barriers to leakage exploitation"></p> <p>The decomposition matters because these three effects are often conflated in informal arguments. A claim like “this leakage is hard to exploit” could mean any of: the leakage is ambiguous, the secret-to-leakage mapping has large fibers, or realistic auxiliary information tends to be misaligned with the true distribution. These are different failure modes with different practical implications, and the bound separates them.</p> <h2 id="query-equality-a-worked-case">Query Equality: A Worked Case</h2> <p>To see what this decomposition buys concretely, consider query-equality leakage — probably the most-studied leakage pattern in encrypted search. An encrypted database processes a sequence of queries (q_1, \ldots, q_n) from an (m)-element alphabet. The leakage reveals which queries are equal (the equality pattern) but not their actual values. We can model this as applying a hidden random bijection (\pi) that maps each query value to a leakage symbol: the adversary sees (\pi(q_1), \ldots, \pi(q_n)) and knows the equality structure but not the labeling.</p> <p>Suppose queries follow a Zipf distribution with parameter (\gamma) and the adversary’s auxiliary distribution is also Zipf (the matched-parameter setting). What does the bound say?</p> <p>The first term (leakage entropy) depends on how many distinct bijections are consistent with the observed equality pattern. When the sequence is long enough to produce many distinct symbols, most bijections are ruled out and this term shrinks. The third term (modal entropy) depends on how well the adversary’s Zipf ranking matches the true ranking. In the matched case it vanishes, because the most-likely assignment under the auxiliary distribution is the correct one. But under mismatch — where the adversary uses the wrong Zipf parameter or gets the ranking wrong — this term can dominate the bound and make it vacuous.</p> <p>Two things emerge from the instantiation. First, scaling helps the adversary: as the number of queries grows relative to the alphabet size, the leakage-entropy term decays. This formalizes the intuition that longer transcripts are more revealing, but it does so quantitatively. Second, auxiliary quality matters in a structured way: ranking mismatch (getting the relative frequency ordering wrong) is a more severe failure mode than parameter mismatch (getting the Zipf exponent wrong). The bound captures this distinction explicitly, which is something raw recovery-rate comparisons cannot do.</p> <h2 id="looking-forward">Looking Forward</h2> <p>The framework through this point gives us a precise language for stating what leakage does and does not contribute to attack success, and structural bounds that reveal where inferential difficulty comes from. But there is a practical limitation: the analysis is still per-model and per-leakage-pattern. Every new profile requires its own instantiation, its own bound calculation, and often its own attack implementation.</p> <p>The next post addresses that limitation directly. Once leakage models are explicit probabilistic objects with the structure described here, they can be encoded as Bayesian networks and attacked through a reusable inference engine. That is where the framework moves from analytical tool to automated methodology.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Seny Kamara. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>